import { PAGE_SIZE, prisma } from "config";
import { StringSearchType } from "persistence/common/enums";
import { Class, NewClass } from "persistence/class/entities";
import { classPrismaRepository } from "persistence/class/repositories";
import { NewUser } from "persistence/users/entities";
import { userPrismaRepository } from "persistence/users/repositories";

describe("Operaciones CRUD Repositorio Clases Prisma", () => {
  const userRepo = userPrismaRepository;
  const repo = classPrismaRepository;

  const userTest: NewUser = {
    email: "test@test.com",
    fatherLastname: "Roman",
    firstName: "Ruben",
    password: "test",
    tuition: "rsro220230",
  };

  const testNew: NewClass = {
    id: "1234",
    className: "class-test",
    subject: "test",
    section: "test",
    ownerId: 1,
  };

  const testCreated: Class = {
    ...testNew,
    modifiedAt: new Date(),
    createdAt: new Date(),
  };

  // Limpia y conecta antes de todos los tests
  beforeAll(async () => {
    await prisma.$connect();
  });

  // Limpia registros y reinicia identidades antes de cada test
  beforeEach(async () => {
    await prisma.$executeRawUnsafe("SET FOREIGN_KEY_CHECKS = 0;");

    // Obtener todas las tablas
    const tables = await prisma.$queryRawUnsafe<{ TABLE_NAME: string }[]>(
      `SELECT TABLE_NAME 
     FROM information_schema.TABLES 
     WHERE TABLE_SCHEMA = DATABASE()`,
    );

    // Truncar cada tabla (elimina datos + reinicia autoincrementos)
    for (const table of tables) {
      await prisma.$executeRawUnsafe(`TRUNCATE TABLE ${table.TABLE_NAME}`);
    }

    // Rehabilitar verificaciones de FK
    await prisma.$executeRawUnsafe("SET FOREIGN_KEY_CHECKS = 1;");

    // Insertar un usuario
    await userRepo.add(userTest);
  });

  // Desconecta al finalizar todos los tests
  afterAll(async () => {
    await prisma.$disconnect();
  });

  test("Agregar un registro", async () => {
    const record = await repo.add(testNew);

    expect({
      id: record?.id,
      className: record?.className,
      subject: record?.subject,
      section: record?.section,
      ownerId: record?.ownerId,
    }).toEqual({
      id: testCreated.id,
      className: testCreated.className,
      subject: testCreated.subject,
      section: testCreated.section,
      ownerId: testCreated.ownerId,
    });
  });

  test("Obtener un registro existente", async () => {
    await repo.add(testNew);
    const record = await repo.get(testNew.id);

    expect({
      id: record?.id,
      className: record?.className,
      subject: record?.subject,
      section: record?.section,
      ownerId: record?.ownerId,
    }).toEqual({
      id: testCreated.id,
      className: testCreated.className,
      subject: testCreated.subject,
      section: testCreated.section,
      ownerId: testCreated.ownerId,
    });
  });

  test("Obtener un registro inexistente", async () => {
    const record = await repo.get("testFail");
    expect(record).toBeUndefined();
  });

  test("Actualizar un registro", async () => {
    const created = await repo.add(testNew);

    const updateData = { ...created, className: "classUpdated" };
    const updated = await repo.update(updateData);

    expect(updated.className).toBe("classUpdated");
    expect(updated.id).toBe(created.id);
  });

  test("Eliminar un registro", async () => {
    await repo.add(testNew);
    const deleted = await repo.delete(testNew.id);
    expect(deleted.id).toBe(testNew.id);

    // Ahora ya no existe
    const record = await repo.get(testNew.id);
    expect(record).toBeUndefined();
  });

  test("Listar con paginación y filtros vacíos", async () => {
    // Inserta varios usuarios
    for (let i = 0; i < 15; i++) {
      await repo.add({
        ...testNew,
        id: `class-${i}`,
      });
    }
    const page = 2;
    const result = await repo.getBy({ page });
    expect(result.page).toBe(page);
    expect(result.totalPages).toBe(Math.ceil(15 / PAGE_SIZE));
    expect(result.results.length).toBeGreaterThan(0);
  });

  test("Filtrado exacto", async () => {
    await repo.add(testNew);
    await repo.add({
      ...testNew,
      id: "class-test-2",
      className: "class-test-find",
    });

    const resultTuition = await repo.getBy({
      page: 1,
      className: { string: "class-test-find", searchType: StringSearchType.EQ },
    });


    expect(resultTuition.results).toHaveLength(1);
    expect(resultTuition.results[0]?.id).toBe("class-test-2");
  });
});
